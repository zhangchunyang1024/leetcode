package bite.I0192;

/**
 * @description: 编写一个函数，输入是一个无符号整数（以二进制串的形式），
 * 返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。
 * <p>
 * 示例 1：
 * 输入：00000000000000000000000000001011
 * 输出：3
 * 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
 * <p>
 * 示例 2：
 * 输入：00000000000000000000000010000000
 * 输出：1
 * 解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
 * <p>
 * 示例 3：
 * 输入：11111111111111111111111111111101
 * 输出：31
 * 解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
 * <p>
 * 来源：力扣（LeetCode）
 * 链接：https://leetcode-cn.com/problems/number-of-1-bits
 * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 * @author: yangyangyang
 * @create: 2020-12-03 20:01
 **/
public class HammingWeightYang
{
    public int hammingWeight(int n)
    {
        /**
         * 每2位byte 统计字节数
         * 1. n & 0x55555555
         *      a. 统计2位字节中低位的字节为1的数量--最多1个，并放在当前位
         * 2. (n >> 1) & 0x55555555
         *      a. 统计2位字节中高位的字节为1的数量--最多1个，并放在当前位
         * 3. n & 0x55555555 + ((n >> 1) & 0x55555555)
         *      a. 每两位中高位 和 低位 中为1的字节数量--最多为
         */
        n = (n & 0x55555555) + ((n >>> 1) & 0x55555555);

        /**
         * 将 每2位byte统计的字节数 相加 结果存放在4个字节中
         */
        n = (n & 0x33333333) + ((n >>> 2) & 0x33333333);

        /**
         * 将 存放在每4个字节中的统计结果 相加 结果存放在8个字节中
         */
        n = (n & 0x0f0f0f0f) + ((n >>> 4) & 0x0f0f0f0f);

        /**
         * 将 存放在每8个字节中的统计结果 相加 结果存放在16个字节中
         */
        n = (n & 0x00ff00ff) + ((n >>> 8) & 0x00ff00ff);

        /**
         * 将 存放在每16个字节中的统计结果 相加 返回
         */
        n = (n & 0x0000ffff) + ((n >>> 16) & 0x0000ffff);

        return n;
    }
}
